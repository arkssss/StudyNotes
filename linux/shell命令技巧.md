 ##    shell命令技巧

* shell就是一个命令解释器
* 有很多版本的shell , bash为比较常用的一个



### 1.命令快捷键

* 「tab」键可以自动补全

*   Ctrl + l 请屏 = clear
*   Ctrl + u 删除此时光标前面所有字符

*  ⬆️⬇️可以查看历史命令



### 2.命令别名

~~~shell
#将rm -rf命令的别名设置为drm
$alias drm="rm -rf"
~~~

~~~shell
#接触别名
$unalias drm
~~~



### 3.输入/输出重定向

* Shell 对与每个程序预定义了3个文件描述字(0,1,2)对应于:

  0 (STDIN) 标准输入 : 键盘

  1 (STDOUT) 标准输出 : 显示屏

  2 (STDERR) 标准错误输出 : 显示屏

* 重定向可以控制输入/输出 不为标准, 既可以从文本或其他渠道进行I/O操作

~~~shell
# > 或 >> 输出重定向
# 将ls -l /tmp 输出的结果不显示在显示屏上 而是重定向到tmp.msg中
# 注意如果tmp.msg不存在, 则会先创建tmp.msg 再执行改命令
# > 但是第二次重定向会覆盖前一次的tmp.msg的结果
# >> 则为追加结果而不是覆盖
$ls -l /tmp > /tmp.msg
~~~



~~~shell
# < 输入重定向
# 将该msg的内容作为广播内容发送
$wall < /etc/tmp.msg
~~~



~~~shell
#错误输出重定向
#只有在该条命令出错的时候才会执行, 且把出错的提醒保存在msg中
#此时为 2> 而不是 > 即为第三种错误输出重定向
$cp -R /usr/backup/usr.bak 2> /bak.error
$ls -l /asd 2> msg
...
~~~





### 4.管道

* 将一个命令的**输出**传给另一个命令作为该命令的**输入**
* 理论上管道可以使用n次

~~~shell
#将$ls -l /etc 的输出的结果传送给 more命令作为输入
$ls -l /etc | more
#可以用多管道
#wc -l [文件] 可以统计该文件的行数
#多管道的使用
#对 $ls -l /etc 的 结果进行 init关键字抓取 再统计行数
#效果 : 统计/etc目录下包含关键字init的文件或目录的个数
$ls -l /etc | grep init | wc -l
~~~





### 5.分号 ; , && , ||

* 分号“;” , 顺序的执行各个命令, 前面命令的正确与否不影响后面命令的执行

  ~~~shell
  #以依次的输出当前的工作目录 , 当前的时间, 当地目录下的文件和目录
  $pwd ; date ;ls -l
  ~~~


* && , 并列多条命令, 当且仅当前面命令执行成功, 才会执行后面的命令

  ~~~shell
  #此时会执行 date , ls -l 而不会执行 pwd
  $date && ls -l && sss && pwd
  ~~~


* || , 当且仅当前面命令执行失败的时候, 才能执行后面的命令, 

  ~~~shell
  #此时不会执行 pwd
  $date || pwd
  #此时会执行 pwd
  $asd || pwd
  ~~~



### 6.``号 (1左边的并不是单引号)

* 命令替换: 将一个命令的输出最为另一个命令的 **参数** (注意并不是输入, 和管道还是有区别)

* 格式为 : 命令1 \`命令2\`

* ~~~shell
  #找到touch命令所在的路径作为ls命令的第三个参数
  $ls -l `which touch`
  ~~~























