# 索引和约束

[TOC]

# 索引

## 为什么引入索引

在向表中插入一行数据的时候, 数据库并不会试图将数据放到表的任何特定的地方, 即数据库 **并不会** 依据某一个字段的大小顺序, 去存储一条记录

相反, 服务器只是 **简单的将数据放在了下一个可以被存放的位置**

所以这就导致了, 如果我们要寻找一条数据, 很可能要通过 **表扫描$^{[1]}$** 的方式才能找到它. 

从而当表中记录特别多的时候, 通过表扫描的方式查找数据便会非常的耗时, 至此我们引出索引概念. 以减小我们查找数据时候的时间复杂度

<small>[1] 表扫描就是依次访问数据库中所有的记录, 找出符合的加入结果集</small>



## 什么是索引

**索引是寻找资源中特定项目的一种机制**, e.g. 书的目录

数据库需要 **使用索引定位表中的行** , 既然使用了 以空间换时间 的思想, 说明我们的数据库中一定额外存储了这些索引的信息表.

索引表就是这样一个表 : 它保存是的用于定位表中一些特殊行或者列的 **物理位置信息** , 而没有保存数据.











## 索引类型

数据库的 **索引类型** 包括如下几种类型 : 

* 唯一索引
* 多列索引



### 唯一索引



唯一性索引就是唯一的意思, 当一列添加唯一索引之后, 数据库添加一行数据的时候

数据库都会去 **检查该列数据的唯一性** , 在确认不存在该数据之后, 数据库才会执行插入操作

~~~
在一些高并发的业务的时候, 保证一列数据的唯一性, 最方便的方法就是去添加一个 唯一性索引
~~~





**唯一性索引** 和 **数据唯一性约束** 的区别

<hr>

可以想象, 如何确保一个字段的唯一性, 如果扫描表的去保证判断是不是和其他字段不同的话, 会非常慢.

**所以在给字段建立一个唯一性束缚的时候, 数据便自动的为我们建立了唯一性索引 !!!**, 从而在检查束缚的时候, 效率会非常高

~~~sql
/*
	添加唯一性束缚 的时候, 数据库都会自动的给这些字段去添加唯一性索引
*/

/* 通过建表的时候创建 */
create table test_unique_index( 
    id smallint unsigned, age smallint,
    constraint pk_table primary key(id), 
    constraint unq_table unique(age)
);

/* 后期通过 alter table 天添加 */
alter table student add unique uni_index (id) 
/* OR */
alter table student add constraint uni_index unique(id)
~~~



**唯一性索引** 和 **主键索引的区别** 

<hr>

主键索引是唯一性索引的一个特殊类

唯一性索引是允许字段为 NULL 的 

主键索引是不允许字段为 NULL 的



### 多列索引

数据库可以为 **两个及以上的列同时创建索引**

建立的时候, 必须考虑 哪一列为第一列, 哪些是第二列

~~~mysql
/*
	给 name, phone 作为多列索引
*/
alter table student add index double_index (name, phone);
~~~





## 索引数据结构

数据库的 **索引数据结构** 包括如下几种类型 : 

* 🌟 B+  树索引
* 哈希索引
* 全文索引
* 空间数据索引



### B+ 树索引


是大多是 MySQL 存储引擎 **默认索引类型**





### 哈希索引

基于 `Hash` 的索引, 可以实现 数据的 `O(1)` 查找







# MySQL 下索引操作

注意 索引是在存储引擎下实现的,  而不是在服务层实现的, 所以不同的存储引擎有着不同的索引实现

`MySQL (8.0)` 下默认的索引为 **B+ 树** 的形式.

如果MySQL建立一张表, 引擎会自动的将 **表的主键, 外键** 作为此表的索引. 也就是说, 一个表的索引可以有多个

~~~sql
/*
	* 增加一个索引
	* 删除一个索引
	* 查看一个索引
	注意以下为 MySQL 下的索引语句, 不同的数据库服务器, 或许有不同的语句
*/


/*
	查看当前表的索引
*/
show index from table_name



/*
	给一个表创建一个索引
	alter table 
		table_name 
	add index 
		index_name (field_name)
*/
alter table student add index my_index (student_id)


/*
	删除一个索引
	alter tabel
		table_bane 
	 drop index
		index_name
*/
alter table student drop index my_index;
~~~





# 主键索引和非主键索引的区别

* **主键索引 :** 默认是数据库创建, 且不能为空, 且数据库一般默认主键索引是 **聚集索引**,  但是也可以在创建表的时候进行指定为 **非聚集索引**



* **非主键索引 :** 需要人工创建, 且数据可以为空, 且可以声明为 **唯一性索引**



# 聚集索引 和  非聚集索引

**聚集索引** 在一个表里面只能有一个, 且就是记录排列的物理顺序

因为对于 **聚集索引** 来说, 在 `B+` 树的叶节点, 存储的就是要查找的数据了

但是对于 **非聚集索引** , `B+` 树的叶节点只是指向该数据的 指针



# 联合索引 与 最左原则

* 需要使用 索引 查询的字段要加在 **Where** 语句中
* 如果 **Where 条件是 OR 关系** , 那么加索引不起作用
* 索引匹配符合 **最左原则**



对于 联合索引的查找, 满足最左匹配原则, 即一次查询可以只使用索引中的一部分, 但一定要是最左侧的部分 e.g : 

~~~
(a, b, c) 的联合索引 可以支持如下的查询
1. a
2. a, b
3. a, b, c
~~~



# B+ 树索引详解

* B+ 树是一个多阶的平衡搜索树, 所有的叶节点同高

* 节点保存索引值, 且父节点的值一定存在于子节点中, 叶节点保存所有的数据

* 父节点保存的为子节点序列的最大或最小值

* 在树的高度而言 B+ 树的高度为 $log_mN$ , 是小于传统的平衡二叉树, 从而查找效率比平衡二叉树更高

* B+ 树所有叶子结点有序首尾相连形成一个链表, 这样做的目的是 极大了方便了范围查询的查询效率

  ~~~sql
  -- B+ 数先找到 id 为1 的叶子结点, 然后往后遍历到100 即可
  select * from student where id > 1 and id < 100
  ~~~

  **注意虽然 B+ 数的叶子结点首尾顺序相连形成一个链表, 但是查找的时候, 还是需要从跟结点出发, 而不能直接从叶头出发**


# 数据库查询优化方案

## 数据库缓存

如果查询有大量的相同重复的 `sql` 语句, 可以直接利用数据库缓存的机制, 将这个查询的结果存储于 **内存** 

且通过一个 `hashMap` 去保存 `key` 即为这个 `sql` 语句. 如果运用到相同的 `sql` 那么直接通过这个散列表获得

不需要再去解析, 优化, 执行 `sql` 了

**如果这个表修改了, 那么使用了这个表的所有的缓存将不再有效, 查询缓存会被清空**



## 通过 Expain 分析索引使用情况

































































