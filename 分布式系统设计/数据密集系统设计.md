# 数据复制

> 数据复制是保证有状态服务高可用的常用手段, 例如mysql的主从, redis的集群模式, 都有数据复制的思想. 
>
> 数据复制的难点在于, 如何保证实时跟新的节点的数据一致性

常见的数据复制架构有以下几种

* 主从架构
* 多主节点架构
* 无主节点架构

我们将一一分析三种架构的利弊

## 主从架构

架构中存在一个主节点, 负责接收写请求, 多个从节点实时更新副本, 并可承担读请求

主从的复制也可以分为以下三种实现

1. 半同步主从
2. 异步主从

### 半同步主从

客户端发送写请求时, 主节点会负责将此次的更新数据 **同步的** 发送到所有的从节点中, **直到有一副本更新成功, 服务端才返回成功**

~~~mermaid
sequenceDiagram
	client->>master: write request (e.g. update xxx)
	master->>slave1: 复制数据流
	master->>slave2: 变更数据
	slave1->>master: ok
	master->>client: ok
	slave2->>master: ok
~~~

优点: 

1. 可以保证 **强一致性**, 即在一次持久化操作后, 所有副本实时更新, 读请求一定可以读取到最新的数据
2. 如果主节点发生故障, 可以最小的代价恢复数据
3. 可以保证集群在任何时间 **至少有两个节点都拥有全量数据**

缺点

1. 同步请求阻塞严重, 性能损耗大, 一般在实际生产中很少使用



### 异步主从

客户端写请求发送给主节点时, **会直接返回结果**, 之后再 **异步的通知各个从节点进行数据变更**

~~~mermaid
sequenceDiagram
	client->>master: write request (e.g. update xxx)
  master->>client: ok
	master->>slave1: 复制数据流
	master->>slave2: 变更数据
	slave1->>master: ok
	slave2->>master: ok
~~~

### 处理节点失效

* 如果失效节点为 **从节点**, 处理起来较为方便, 只需要从节点记录失效时的最后一笔事务, 再请求主节点之后的每一个笔数据变更, 直到数据达到最新即可
* 如果失效节点为 **主节点**. 则需要按以下步骤处理
  1. 选举 **新的主节点**, 一般从从节点中采用 **多数节点共识** 的方法, 将一个从节点选举为一个新的主节点, 接管此时的写请求
  2. 将 **新主节点** 的消息广播所有从节点



### 复制技术的实现

> 这里以mysql-innodb为例阐述复制的过程

mysql复制技术依赖两种日志的配合

1. `binlog` : 记录主节点的所有写操作, 例如 update, insert, ... **注意没有影响行的写操作也会被记录**

2. `relaylog`: 从节点中继日志, 负责同步binlog内容, 重放到从节点

   <img src="images/mysql-replication.png" />





























