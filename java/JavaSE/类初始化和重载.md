## 类初始化和重载



### 1. 类的初始化构造函数

* 和c++一样, java中类的构造函数名就是**类名**
* 构造函数**没有返回值**, 且与void返回值有明显的区别
* 当对象没有定义构造方法的时候, 编译器自动的调用默认构造方法, **但是一但定义了, 便只能按定义的构造方法的参数列表传递**

~~~java

class demo1{
    // contructor
    public demo1(int i){}
    // overload
	public demo1(string s){}
}


~~~

### 2. finalize函数

Java的finalize函数可以对应与c++的析构函数, 但是也有本质的区别

~~~java
    @Override
    protected void finalize() throws Throwable {
        
        // super函数可以调用基类的finalize方法
        super.finalize();
    }
~~~



* finalize() 函数 : 是自动到java启动垃圾回收的时候调用, 但是垃圾回收的启动是在系统可用内存快溢出, java程序自动进行的, 就是说在**内存充足的情况下, 系统不会启动垃圾回收机制** 也就不会掉用finalize函数, 但是c++的析构函数是在一个对象的生存时间就必须掉用的.



### 3. 重载(overload)和重写(override)

#### 3.1 重载

> 重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。
>
> 每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。
>
> 最常用的地方就是构造器的重载。

**java中舍弃了c++中的操作符重载的规则**





#### 3.2 重写

**在子类中对于父类的相同的方法重新定义**

~~~java
class father{
    public void fa(){
		
    }
}

class son extends father{
    // 重写
    public void fa(){
		
        
        // 可以调用父类的相应函数
        super.fa();
    }
    
    // 子类的特有方法
    public void son(){
        
    }
}

~~~



* 在子类重写的方法中, **必须参数列表和返回值和父类完全一致**
* 可以重写的前提是**可以继承该方法**
* 父类中声明为final的方法不可以被重写
* 父类中声明为static的方法不可以被重写但是可以被重写声明



关于声明

~~~java
public static void main(String args[]){
    	
    // 利用父类名实例化子类
    father son1 = new son();
    // 可以调用子类的重写fa方法
    son1.fa();
    // 但是不可以调用子类的特有方法
    // ❌
    son1.son(); 
    
    // 以子类的类明声明
    son son2 = new son();
    
    // 可以调用子类特有的方法
    // right
    son2.son()
}
~~~



####3.3 两者区别

| 区别点   | 重载方法 | 重写方法                                       |
| -------- | -------- | ---------------------------------------------- |
| 参数列表 | 必须修改 | 一定不能修改                                   |
| 返回类型 | 可以修改 | 一定不能修改                                   |
| 异常     | 可以修改 | 可以减少或删除，一定不能抛出新的或者更广的异常 |
| 访问     | 可以修改 | 一定不能做更严格的限制（可以降低限制）         |













































