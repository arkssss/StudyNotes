## 一切皆对象

### 1. 两种声明的区别

* 未初始化的声明方式

  ~~~java
  String s;
  ~~~

  **注意此中方式并不推荐, 因为指数创建了一个(handle),  而并没有和任何对象关联**

* 第一种

  ~~~java
  String str1 = "abc";
  // true
  System.out.println(str1 == "abc");     
  ~~~

  1 : 在 **栈中** 开辟一个空间, 存放str1引用

  2 : 在 **String 常量池** 中开辟一块空间存放 "abc" 对象

  3 : 引用str1 指向 常量池中的 "abc" 对象

  4 : str 此时就是指代常量池中"abc"的地址



* 第二种

  ~~~java
  String str1 = new String("abc");
  // false 
  System.out.println(str1 == "abc");   
  ~~~

  1. 在 **栈** 中开辟一个空间存放 str1 
  2. 在 **堆** 中开辟一块空间存放一个新建的String 对象
  3. 引用 str1 指向 堆 在中新创建的对象
  4. 所以此时的str1是指向的 **堆中** 的新对象的地址, 而不是 常量池中的 "abc"



  Tips : 

  * 对于new 方法创建的对象, java会先去查看常量池中有没有 "abc" 对象, **如果有** : 则 直接在堆区中生成一个该对象的拷贝对象 (**但是还是还在堆中**) , 如果没有则现在 常量池中生成 "abc"对象 , 然后再拷贝到堆中

    所以 **通过new 方法, 生成的过程中, 可能创建了一个(常量池中有) 或者 两个对象(常量池中没有)**





### 2. 关于存储区域

* 堆栈(RAM) 中存放java中的 **引用(对象的句柄handle), 等数据**  , 由于栈指针的存在, 所以放入其中的元素必须要知道其长度和存放时间, 这样才能保证指针的准确移动.  实例化的对象不保存在其中
* 堆(Heap)(RAM) 中不考虑放入元素的长度, 时间等, 所以更为灵活. **所以用来保存java的对象, 如new语句创建的对象**
* 静态存储 (RAM) 指位于固定位置的数据, 切在程序开始运行前就需要放入
* 常量存储 : 放于ROM中



tips : 

* Java 中的基本数据类型,**当不使用new 的形式声明时 (非句柄形式创建)**, 就直接存放于堆栈区

* Java 的八种数据类型中, 统一都是有符号的

* Java 的数据类型大小, 定义与OS之上 (java 跨平台的保障)

  ~~~java
  // java 的基本数据类型
  // 后面的值是 不进行初始化时的默认值
  boolean ;// false	
  char ;	 // null
  byte ;	 // 0
  short ;	 // 0
  int ; 	 // 0
  long ;	 // 0L
  float ;  // 0.0f
  double ; // 0.0d
  
  
  // 当以这种方式声明的时候, 会被直接存放在堆栈区 而不是堆区
  int a = 10 ;
  
  ~~~



###3. 关于程序中基本类型的初始值

~~~java
// 如果在类的成员变量中, 没有初始化
class Demo{
    	
    int a;	     // 此时外界调用 a 的默认值就是 0 
    int b = 10;  // 注意这种写法是 可以的!
    
}


// 如果在函数中, 没有初始化直接调用, 则会报错
public void test(){
    int a ;
    System.out.println(a)	// 编译错误
}


~~~



### 4. 对象的作用域 及 垃圾回收 

java 类似于 C++ 以及 C , 一个对象的作用域存在于花括号内{}

* 有一点区别 

  ~~~java
  {
  	int a = 10;
      
      {	
          //这种情况在java编译的时候会报错, 但是在c++时只是会覆盖
          int a = 20;
      }
      
  }
  ~~~

* java 的垃圾回收机制

  ~~~java
  {
      
      String s = new String("123");
      
  }// 句柄s在花括号结束的时候, 就会被删除
  ~~~

  句柄被删除, **但是在堆区的对象的内存并不会被清空**, 这就意味着, 我们永远也无法访问到堆区的这个对象.从而导致了**内存固化**

  * C++ 中在在一个声明的作用域结束后, 必须释放该内存
  * Java 中提供了垃圾回收机制, 可以使得我们不需要手动的去释放, 程序会自动的检测未使用的对象进行删除
  * Java 中的垃圾回收机制只可以自动释放由new生成的对象



### 5. Java方法 和 公共函数库

* 由于java的特性, 所有的java函数(方法),  必须被放置于类中, (区别与其他语言的公共函数库)

* Java的静态类可以实现其他语言的公共函数库的功能

  ~~~java
  // 注意, 区别于c++, java并不能给类声明为静态的, 只能给类的成员声明为静态
  class StaticClass{
      
      public static int i = 1;
      public static void Test(){return "123";}
      ...
      
  }
  
  //在调用的时候, 类的静态成员, 会被事先的载入内存的静态区域, 同时在new这个类的时候, 该成员不会被new一 // 次, 而是一直指向静态区域的该量
  class Main{
      public static viod main(args[]){
          	
          StaticClass s1 = new StaticClass();
          StaticClass s2 = new StaticClass();
          
          s1.i++;
          // 输出为2, 即s1,s2的成员i指向同一个内存
          System.out.printl(s2.i) 
              
      }
  }
  ~~~



































